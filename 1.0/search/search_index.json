{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyDeployment Deploy Python projects with ease. PyDeployment provides an easy way to package Python projects on Windows, macOS, and Linux. This project is a wrapper that leverages existing software to take your project from repository to executable file. If you can run it with Python, you can deploy it with PyDeployment. Read the User Guide to learn about installing and using PyDeployment. How PyDeployment Works PyDeployment uses PyInstaller to create an application directory. This created directory is then bundled into the preferred distribution method for the platform. On Windows, NSIS is used to create an installer (EXE). On macOS, the hdiutil command is used to create an Apple disk image (DMG). On Linux, appimagetool is used to create an AppImage. Examples The following examples showcase build systems which utilize PyDeployment to build their applications. These examples are themselves template repositories available for use. Examples are in progress","title":"Home"},{"location":"#pydeployment","text":"Deploy Python projects with ease. PyDeployment provides an easy way to package Python projects on Windows, macOS, and Linux. This project is a wrapper that leverages existing software to take your project from repository to executable file. If you can run it with Python, you can deploy it with PyDeployment. Read the User Guide to learn about installing and using PyDeployment.","title":"PyDeployment"},{"location":"#how-pydeployment-works","text":"PyDeployment uses PyInstaller to create an application directory. This created directory is then bundled into the preferred distribution method for the platform. On Windows, NSIS is used to create an installer (EXE). On macOS, the hdiutil command is used to create an Apple disk image (DMG). On Linux, appimagetool is used to create an AppImage.","title":"How PyDeployment Works"},{"location":"#examples","text":"The following examples showcase build systems which utilize PyDeployment to build their applications. These examples are themselves template repositories available for use. Examples are in progress","title":"Examples"},{"location":"about/contributing/","text":"Contributing to PyDeployment Guidelines for contributing to PyDeployment. Feel free to contribute to the project by sending pull requests or reporting issues to the GitHub repository. As a simple wrapper script, PyDeployment's scope is limited by design, so please keep that in mind when submitting requests for features or other improvements. Code of Conduct All contributors and maintainers are expected to abide by the PyPA Code of Conduct . Testing the Development Version You can install the development version from the project repository itself. First, clone the repository and enter the project directory. git clone https://github.com/pydeployment/pydeployment && cd pydeployment Then, create a virtual environment. python -m venv --upgrade-deps venv Install the testing requirements. venv/bin/pip install -r requirements_pytest.txt Finally, install the project in editable mode. venv/bin/pip install --editable . Run any of the scripts in the tests directory to conduct tests on a specific aspect of PyDeployment, or run the following command to conduct all tests. venv/bin/pytest tests/ In order to test macOS notarization, you will need to create a file named .env in the project directory with the information necessary to notarize an application. See macOS Notarization for details on the necessary values. CERT=\"Developer ID Application: Name Here (TEAMIDHERE)\" KEYC=\"keychain-profile-name\"","title":"Contributing"},{"location":"about/contributing/#contributing-to-pydeployment","text":"Guidelines for contributing to PyDeployment. Feel free to contribute to the project by sending pull requests or reporting issues to the GitHub repository. As a simple wrapper script, PyDeployment's scope is limited by design, so please keep that in mind when submitting requests for features or other improvements.","title":"Contributing to PyDeployment"},{"location":"about/contributing/#code-of-conduct","text":"All contributors and maintainers are expected to abide by the PyPA Code of Conduct .","title":"Code of Conduct"},{"location":"about/contributing/#testing-the-development-version","text":"You can install the development version from the project repository itself. First, clone the repository and enter the project directory. git clone https://github.com/pydeployment/pydeployment && cd pydeployment Then, create a virtual environment. python -m venv --upgrade-deps venv Install the testing requirements. venv/bin/pip install -r requirements_pytest.txt Finally, install the project in editable mode. venv/bin/pip install --editable . Run any of the scripts in the tests directory to conduct tests on a specific aspect of PyDeployment, or run the following command to conduct all tests. venv/bin/pytest tests/ In order to test macOS notarization, you will need to create a file named .env in the project directory with the information necessary to notarize an application. See macOS Notarization for details on the necessary values. CERT=\"Developer ID Application: Name Here (TEAMIDHERE)\" KEYC=\"keychain-profile-name\"","title":"Testing the Development Version"},{"location":"about/license/","text":"License Licenses for PyDeployment and included projects. Included Projects NSIS Portable NSIS Portable is included in its entirety, unmodified, so that PyDeployment can use the makensis.exe binary to create installers from NSIS scripts. NSIS Portable is licensed under the GPL. A copy of the license can be found here: LICENSE appimagetool The appimagetool binaries for aarch64, armhf, i686, and x86_64 architectures are included so that PyDeployment can use them to create AppImage files. The aforementioned binaries are licensed under the MIT License for AppImageKit. A copy of the license can be found here: LICENSE pynsist The default NSIS script of PyDeployment was largely adapted from the file pyapp.nsi which is licensed under the MIT License. A copy of the license can be found here: LICENSE MkDocs The documentation website for PyDeployment adapts large portions of the code from the MkDocs website, including but not limited to the CSS file and navigation structure. MkDocs is licensed under the BSD-2-Clause License. A copy of the license can be found here: LICENSE PyDeployment License MIT License Copyright (c) 2024 Zev Lee Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"Licenses for PyDeployment and included projects.","title":"License"},{"location":"about/license/#included-projects","text":"NSIS Portable NSIS Portable is included in its entirety, unmodified, so that PyDeployment can use the makensis.exe binary to create installers from NSIS scripts. NSIS Portable is licensed under the GPL. A copy of the license can be found here: LICENSE appimagetool The appimagetool binaries for aarch64, armhf, i686, and x86_64 architectures are included so that PyDeployment can use them to create AppImage files. The aforementioned binaries are licensed under the MIT License for AppImageKit. A copy of the license can be found here: LICENSE pynsist The default NSIS script of PyDeployment was largely adapted from the file pyapp.nsi which is licensed under the MIT License. A copy of the license can be found here: LICENSE MkDocs The documentation website for PyDeployment adapts large portions of the code from the MkDocs website, including but not limited to the CSS file and navigation structure. MkDocs is licensed under the BSD-2-Clause License. A copy of the license can be found here: LICENSE","title":"Included Projects"},{"location":"about/license/#pydeployment-license","text":"MIT License Copyright (c) 2024 Zev Lee Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"PyDeployment License"},{"location":"about/release-notes/","text":"Release Notes Version 1.0.1 Edit CLI description to reduce confusion Version 1.0.0 Initial commit","title":"Release Notes"},{"location":"about/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"about/release-notes/#version-101","text":"Edit CLI description to reduce confusion","title":"Version 1.0.1"},{"location":"about/release-notes/#version-100","text":"Initial commit","title":"Version 1.0.0"},{"location":"user-guide/","text":"User Guide Packaging a project using PyDeployment. The PyDeployment User Guide provides documentation on using the features of PyDeployment. Select any of the items below or use the next and previous buttons in the navigation bar at the top of the page to move through the documentation in order. Getting Started Build Options Setting Build Options Using an Environment File Using the Command Line Using Both Advanced Usage Package as an Archive File Using a Custom Virtual Environment Using a Custom NSIS File Using a Custom Makensis Binary macOS Notarization Using a Custom Appimagetool Binary Passing Arguments to PyInstaller","title":"User Guide"},{"location":"user-guide/#user-guide","text":"Packaging a project using PyDeployment. The PyDeployment User Guide provides documentation on using the features of PyDeployment. Select any of the items below or use the next and previous buttons in the navigation bar at the top of the page to move through the documentation in order. Getting Started Build Options Setting Build Options Using an Environment File Using the Command Line Using Both Advanced Usage Package as an Archive File Using a Custom Virtual Environment Using a Custom NSIS File Using a Custom Makensis Binary macOS Notarization Using a Custom Appimagetool Binary Passing Arguments to PyInstaller","title":"User Guide"},{"location":"user-guide/build-options/","text":"Build Options List of all possible options to set. PyDeployment recognizes the following build options. See Setting Build Options for details on how to set these options. Universal Build Options Option Name Type Description Default --log LOG text Set the log level. Can choose among 'DEBUG' , 'INFO' , 'WARNING' , 'ERROR' . Setting the log level to 'WARNING' avoids asking the user for confirmation of the build. Setting the log level to 'ERROR' also avoids asking the user for confirmation to delete preexisting build artifacts. 'INFO' -y , --no-confirm NO_CONFIRM boolean Do not ask for confirmation. Automatically proceeds with build and deletes preexisting build artifacts. False --no-clean NO_CLEAN boolean Do not delete build artifacts after completing the build process. False --archive ARCHIVE boolean Package as an archive file. See Package as an Archive File . False -f , --filename FILENAME text Output filename without version and architecture. Must not contain white space or any other characters which are disallowed in file names. Basename of the Python script or PyInstaller spec file. -a , --appname APPNAME text Application name. The value of FILENAME --id ID text Application ID. Should follow reverse DNS format. 'id.not.found.' + The value of FILENAME --appv , --app-version VERSION text Application version. None --author AUTHOR text Author. None --publisher PUBLISHER text Publisher. The value of AUTHOR -d , --description DESCRIPTION text Application description. None --pyi-version PYI_VERSION text PyInstaller version to be used. The latest version of PyInstaller -i , --icon ICON path Path to icon file. Path to the PyDeployment logo -l , --license LICENSE path Path to license file. Path pointing to a single-line temporary text file with the content: 'Copyright (c) ' + the value of AUTHOR -o , --outdir OUTDIR path Path to output directory. 'dist' -r , --requirements REQUIREMENTS path Path to pip requirements file. The listed packages will be installed along with PyInstaller. This option is ignored if VENV is set. None --venv VENV path Path to Python virtual environment. See Using a Custom Virtual Environment . None Windows Build Options Option Name Type Description Default --nsis NSIS path Path to NSIS file. See Using a Custom NSIS File . Path to PyDeployment's default NSIS file 'build.nsi' --makensis MAKENSIS path Path to makensis binary. See Using a Custom Makensis Binary . Path to PyDeployment's included makensis binary makensis.exe macOS Build Options See macOS Notarization to learn about these options and how they are used. Option Name Type Description Default -E , --enti , --entitlements ENTI path Path to entitlements file. Path to PyDeployment's default entitlements file 'entitlements.plist' -C , --cert , --certificate CERT text Common Name of Certificate. None -K , --keyc , --keychain-profile KEYC text Name of stored Keychain Profile. None -A , --apid , --apple-id APID text Apple ID. None -T , --tmid , --team-id TMID text Team ID. None -P , --pass , --password PASS text App-specific Password. None Linux Build Options Option Name Type Description Default --appdata APPDATA path Path to AppStream metadata file. File name should be in the form: The value of ID + '.appdata.xml' . None --appimagetool APPIMAGETOOL path Path to appimagetool. See Using a Custom Appimagetool Binary . Path to PyDeployment's included appimagetool 'appimagetool-*.AppImage' , whichever one matches the architecture of the system.","title":"Build Options"},{"location":"user-guide/build-options/#build-options","text":"List of all possible options to set. PyDeployment recognizes the following build options. See Setting Build Options for details on how to set these options.","title":"Build Options"},{"location":"user-guide/build-options/#universal-build-options","text":"Option Name Type Description Default --log LOG text Set the log level. Can choose among 'DEBUG' , 'INFO' , 'WARNING' , 'ERROR' . Setting the log level to 'WARNING' avoids asking the user for confirmation of the build. Setting the log level to 'ERROR' also avoids asking the user for confirmation to delete preexisting build artifacts. 'INFO' -y , --no-confirm NO_CONFIRM boolean Do not ask for confirmation. Automatically proceeds with build and deletes preexisting build artifacts. False --no-clean NO_CLEAN boolean Do not delete build artifacts after completing the build process. False --archive ARCHIVE boolean Package as an archive file. See Package as an Archive File . False -f , --filename FILENAME text Output filename without version and architecture. Must not contain white space or any other characters which are disallowed in file names. Basename of the Python script or PyInstaller spec file. -a , --appname APPNAME text Application name. The value of FILENAME --id ID text Application ID. Should follow reverse DNS format. 'id.not.found.' + The value of FILENAME --appv , --app-version VERSION text Application version. None --author AUTHOR text Author. None --publisher PUBLISHER text Publisher. The value of AUTHOR -d , --description DESCRIPTION text Application description. None --pyi-version PYI_VERSION text PyInstaller version to be used. The latest version of PyInstaller -i , --icon ICON path Path to icon file. Path to the PyDeployment logo -l , --license LICENSE path Path to license file. Path pointing to a single-line temporary text file with the content: 'Copyright (c) ' + the value of AUTHOR -o , --outdir OUTDIR path Path to output directory. 'dist' -r , --requirements REQUIREMENTS path Path to pip requirements file. The listed packages will be installed along with PyInstaller. This option is ignored if VENV is set. None --venv VENV path Path to Python virtual environment. See Using a Custom Virtual Environment . None","title":"Universal Build Options"},{"location":"user-guide/build-options/#windows-build-options","text":"Option Name Type Description Default --nsis NSIS path Path to NSIS file. See Using a Custom NSIS File . Path to PyDeployment's default NSIS file 'build.nsi' --makensis MAKENSIS path Path to makensis binary. See Using a Custom Makensis Binary . Path to PyDeployment's included makensis binary makensis.exe","title":"Windows Build Options"},{"location":"user-guide/build-options/#macos-build-options","text":"See macOS Notarization to learn about these options and how they are used. Option Name Type Description Default -E , --enti , --entitlements ENTI path Path to entitlements file. Path to PyDeployment's default entitlements file 'entitlements.plist' -C , --cert , --certificate CERT text Common Name of Certificate. None -K , --keyc , --keychain-profile KEYC text Name of stored Keychain Profile. None -A , --apid , --apple-id APID text Apple ID. None -T , --tmid , --team-id TMID text Team ID. None -P , --pass , --password PASS text App-specific Password. None","title":"macOS Build Options"},{"location":"user-guide/build-options/#linux-build-options","text":"Option Name Type Description Default --appdata APPDATA path Path to AppStream metadata file. File name should be in the form: The value of ID + '.appdata.xml' . None --appimagetool APPIMAGETOOL path Path to appimagetool. See Using a Custom Appimagetool Binary . Path to PyDeployment's included appimagetool 'appimagetool-*.AppImage' , whichever one matches the architecture of the system.","title":"Linux Build Options"},{"location":"user-guide/getting-started/","text":"Getting Started Installation and basic usage. Requirements PyDeployment requires Python version 3.10 or higher and a recent version of pip . Installing PyDeployment Install PyDeployment with pip using the following command. pip install --user pydeployment Basic Usage Use the command pydeploy with a Python script or PyInstaller spec file as the target file. pydeploy myapp.py PyDeployment will run PyInstaller and package the resulting output into the preferred distribution format of the platform on which PyDeployment was run. On Windows, NSIS is used to create an installer (EXE). On macOS, the hdiutil command is used to create an Apple disk image (DMG). On Linux, appimagetool is used to create an AppImage. Read Build Options to learn about the values you can set for your project.","title":"Getting Started"},{"location":"user-guide/getting-started/#getting-started","text":"Installation and basic usage.","title":"Getting Started"},{"location":"user-guide/getting-started/#requirements","text":"PyDeployment requires Python version 3.10 or higher and a recent version of pip .","title":"Requirements"},{"location":"user-guide/getting-started/#installing-pydeployment","text":"Install PyDeployment with pip using the following command. pip install --user pydeployment","title":"Installing PyDeployment"},{"location":"user-guide/getting-started/#basic-usage","text":"Use the command pydeploy with a Python script or PyInstaller spec file as the target file. pydeploy myapp.py PyDeployment will run PyInstaller and package the resulting output into the preferred distribution format of the platform on which PyDeployment was run. On Windows, NSIS is used to create an installer (EXE). On macOS, the hdiutil command is used to create an Apple disk image (DMG). On Linux, appimagetool is used to create an AppImage. Read Build Options to learn about the values you can set for your project.","title":"Basic Usage"},{"location":"user-guide/advanced/","text":"Advanced Usage Advanced build options. Click on the options below to learn about advanced build options. Package as an Archive File Using a Custom Virtual Environment Using a Custom NSIS File Using a Custom Makensis Binary macOS Notarization Using a Custom Appimagetool Binary Passing Arguments to PyInstaller","title":"Advanced Usage"},{"location":"user-guide/advanced/#advanced-usage","text":"Advanced build options. Click on the options below to learn about advanced build options. Package as an Archive File Using a Custom Virtual Environment Using a Custom NSIS File Using a Custom Makensis Binary macOS Notarization Using a Custom Appimagetool Binary Passing Arguments to PyInstaller","title":"Advanced Usage"},{"location":"user-guide/advanced/archive-file/","text":"Package as an Archive File An alternative packaging method. Instead of the preferred distribution method for the platform, you can choose to package the output of PyInstaller as an archive file. On Windows, the file will be a ZIP file. On macOS and Linux, the file will be a tarball compressed with LZMA (TXZ).","title":"Package as an Archive File"},{"location":"user-guide/advanced/archive-file/#package-as-an-archive-file","text":"An alternative packaging method. Instead of the preferred distribution method for the platform, you can choose to package the output of PyInstaller as an archive file. On Windows, the file will be a ZIP file. On macOS and Linux, the file will be a tarball compressed with LZMA (TXZ).","title":"Package as an Archive File"},{"location":"user-guide/advanced/custom-appimagetool/","text":"Using a Custom Appimagetool Binary Specify your own appimagetool binary. Although appimagetool binaries are included with PyDeployment, you can instead choose to use your own appimagetool binary by providing the path to the binary to APPIMAGETOOL in the environment file or --appimagetool on the command line.","title":"Using a Custom Appimagetool Binary"},{"location":"user-guide/advanced/custom-appimagetool/#using-a-custom-appimagetool-binary","text":"Specify your own appimagetool binary. Although appimagetool binaries are included with PyDeployment, you can instead choose to use your own appimagetool binary by providing the path to the binary to APPIMAGETOOL in the environment file or --appimagetool on the command line.","title":"Using a Custom Appimagetool Binary"},{"location":"user-guide/advanced/custom-makensis/","text":"Using a Custom Makensis Binary Specify your own makensis binary. Although a makensis binary is included with PyDeployment, you can instead choose to use your own makensis binary by providing the path to the binary to MAKENSIS in the environment file or --makensis on the command line.","title":"Using a Custom Makensis Binary"},{"location":"user-guide/advanced/custom-makensis/#using-a-custom-makensis-binary","text":"Specify your own makensis binary. Although a makensis binary is included with PyDeployment, you can instead choose to use your own makensis binary by providing the path to the binary to MAKENSIS in the environment file or --makensis on the command line.","title":"Using a Custom Makensis Binary"},{"location":"user-guide/advanced/custom-nsis/","text":"Using a Custom NSIS File Use a custom NSIS template file. You can use a custom NSIS script rather than the one provided by PyDeployment by specifying the path to the file to NSIS in the environment file or --nsis on the command line. If you wish to use the variables provided by PyDeployment, be sure to include the following header at the top of the file. !define /file APPDIR \"APPDIR\" !define /file FILENAME \"FILENAME\" !define /file APPNAME \"APPNAME\" !define /file VERSION \"VERSION\" !define /file AUTHOR \"AUTHOR\" !define /file PUBLISHER \"PUBLISHER\" !define /file DESCRIPTION \"DESCRIPTION\" !define /file ICON \"ICON\" !define /file LICENSE \"LICENSE\" !define /file INSTALLSIZE \"INSTALLSIZE\" !define /file ARCH \"ARCH\"","title":"Using a Custom NSIS File"},{"location":"user-guide/advanced/custom-nsis/#using-a-custom-nsis-file","text":"Use a custom NSIS template file. You can use a custom NSIS script rather than the one provided by PyDeployment by specifying the path to the file to NSIS in the environment file or --nsis on the command line. If you wish to use the variables provided by PyDeployment, be sure to include the following header at the top of the file. !define /file APPDIR \"APPDIR\" !define /file FILENAME \"FILENAME\" !define /file APPNAME \"APPNAME\" !define /file VERSION \"VERSION\" !define /file AUTHOR \"AUTHOR\" !define /file PUBLISHER \"PUBLISHER\" !define /file DESCRIPTION \"DESCRIPTION\" !define /file ICON \"ICON\" !define /file LICENSE \"LICENSE\" !define /file INSTALLSIZE \"INSTALLSIZE\" !define /file ARCH \"ARCH\"","title":"Using a Custom NSIS File"},{"location":"user-guide/advanced/custom-venv/","text":"Using a Custom Virtual Environment Use your own virtual environment. By default, PyDeployment creates a virtual environment and installs PyInstaller along with any requirements specified by the requirements file. It is possible to instead specify your own virtual environment created by the venv module. In this case, the requirements file will be ignored. To do so, provide the path to VENV in the environment file or --venv on the command line. Be sure that PyInstaller is installed in the virtual environment that you specify.","title":"Using a Custom Virtual Environment"},{"location":"user-guide/advanced/custom-venv/#using-a-custom-virtual-environment","text":"Use your own virtual environment. By default, PyDeployment creates a virtual environment and installs PyInstaller along with any requirements specified by the requirements file. It is possible to instead specify your own virtual environment created by the venv module. In this case, the requirements file will be ignored. To do so, provide the path to VENV in the environment file or --venv on the command line. Be sure that PyInstaller is installed in the virtual environment that you specify.","title":"Using a Custom Virtual Environment"},{"location":"user-guide/advanced/github-workflows/","text":"Using GitHub Workflows Automate your package deployment. Section is still being written.","title":"Using GitHub Workflows"},{"location":"user-guide/advanced/github-workflows/#using-github-workflows","text":"Automate your package deployment. Section is still being written.","title":"Using GitHub Workflows"},{"location":"user-guide/advanced/macos-notarization/","text":"macOS Notarization Sign and notarize your app on macOS. Applications on macOS need to be notarized by Apple in order to run on other macOS devices without warning. This is accomplished by code signing the app bundle generated by PyInstaller, submitting the file to Apple, then stapling a notarization ticket to the app bundle. Requirements Code signing an app bundle requires an active Apple Developer account. You will need to create a Developer ID certificate for signing applications. Follow the instructions on the Apple Developer support page to create a Developer ID certificate. You will need to install Xcode 13 or later to gain access to the xcrun command, which PyDeployment uses during the notarization process. You may need to use the xcode-select utility to choose an appropriate version of Xcode. sudo xcode-select -s /path/to/Xcode13.app Code Sign To code sign the app bundle generated by PyInstaller, include the Common Name of your Developer ID certificate in your build options. This can be included as CERT in the environment file or by using -C , --cert , or --certificate to include the value as a command line argument. For example, the following command will code sign the application generated by myapp.spec with the specified Developer ID certificate. pydeploy myapp.spec -C 'Developer ID Application: Name Here (TEAMIDHERE)' Note that this application will still need to be submitted for notarization separately. Notarize With a Stored Keychain Profile If you wish to both sign and notarize your application, you have two options for information to include. Option 1 Option 2 Name of a stored Keychain Profile Apple ID, Team ID, and an App-Specific Password You will want to create an App Store Connect API key and save it locally on your device. Then run the following command to store the Keychain Profile with the name of your choice. xcrun notarytool store-credentials 'profile-name' -k <key> -d <key-id> -i <issuer> The field <key> refers to the path to the App Store Connect API Key. Field <key-id> refers to the App Store Connect API Key ID, which is usually 10 alphanumeric characters. The field <issuer> refers to the App Store Connect Issuer ID, which is in UUID format. It is possible to store a Keychain Profile using the information in Option 2. Use the following command to do so. xcrun notarytool store-credentials `keychain-profile-name` --apple-id <apple-id> --team-id <team-id> --password <password> The field <apple-id> refers to your Apple ID, an email address. Field <team-id> refers to your Team ID, which is usually 10 uppercase alphanumeric characters. The field <password> refers to the an App-Specific Password, which has the format of 16 lowercase alphabetical characters separated into groups of 4 characters by hyphens, e.g. pass-word-goes-here . With your Keychain Profile now stored, you may now use PyDeployment while specifying its name. pydeploy myapp.spec -C 'Developer ID Application: Name Here (TEAMIDHERE)' -K 'profile-name' It is recommended to use an App Store Connect API Key to store a Keychain Profile, as App-Specific Passwords tend to be more fickle. Notarize Without a Stored Keychain Profile If you do not wish to store your information in a Keychain Profile, you can feed the information from Option 2 directly to PyDeployment for notarization. pydeploy myapp.spec -C 'Developer ID Application: Name Here (TEAMIDHERE)' -A <apple-id> -T <team-id> -P <password>","title":"macOS Notarization"},{"location":"user-guide/advanced/macos-notarization/#macos-notarization","text":"Sign and notarize your app on macOS. Applications on macOS need to be notarized by Apple in order to run on other macOS devices without warning. This is accomplished by code signing the app bundle generated by PyInstaller, submitting the file to Apple, then stapling a notarization ticket to the app bundle.","title":"macOS Notarization"},{"location":"user-guide/advanced/macos-notarization/#requirements","text":"Code signing an app bundle requires an active Apple Developer account. You will need to create a Developer ID certificate for signing applications. Follow the instructions on the Apple Developer support page to create a Developer ID certificate. You will need to install Xcode 13 or later to gain access to the xcrun command, which PyDeployment uses during the notarization process. You may need to use the xcode-select utility to choose an appropriate version of Xcode. sudo xcode-select -s /path/to/Xcode13.app","title":"Requirements"},{"location":"user-guide/advanced/macos-notarization/#code-sign","text":"To code sign the app bundle generated by PyInstaller, include the Common Name of your Developer ID certificate in your build options. This can be included as CERT in the environment file or by using -C , --cert , or --certificate to include the value as a command line argument. For example, the following command will code sign the application generated by myapp.spec with the specified Developer ID certificate. pydeploy myapp.spec -C 'Developer ID Application: Name Here (TEAMIDHERE)' Note that this application will still need to be submitted for notarization separately.","title":"Code Sign"},{"location":"user-guide/advanced/macos-notarization/#notarize-with-a-stored-keychain-profile","text":"If you wish to both sign and notarize your application, you have two options for information to include. Option 1 Option 2 Name of a stored Keychain Profile Apple ID, Team ID, and an App-Specific Password You will want to create an App Store Connect API key and save it locally on your device. Then run the following command to store the Keychain Profile with the name of your choice. xcrun notarytool store-credentials 'profile-name' -k <key> -d <key-id> -i <issuer> The field <key> refers to the path to the App Store Connect API Key. Field <key-id> refers to the App Store Connect API Key ID, which is usually 10 alphanumeric characters. The field <issuer> refers to the App Store Connect Issuer ID, which is in UUID format. It is possible to store a Keychain Profile using the information in Option 2. Use the following command to do so. xcrun notarytool store-credentials `keychain-profile-name` --apple-id <apple-id> --team-id <team-id> --password <password> The field <apple-id> refers to your Apple ID, an email address. Field <team-id> refers to your Team ID, which is usually 10 uppercase alphanumeric characters. The field <password> refers to the an App-Specific Password, which has the format of 16 lowercase alphabetical characters separated into groups of 4 characters by hyphens, e.g. pass-word-goes-here . With your Keychain Profile now stored, you may now use PyDeployment while specifying its name. pydeploy myapp.spec -C 'Developer ID Application: Name Here (TEAMIDHERE)' -K 'profile-name' It is recommended to use an App Store Connect API Key to store a Keychain Profile, as App-Specific Passwords tend to be more fickle.","title":"Notarize With a Stored Keychain Profile"},{"location":"user-guide/advanced/macos-notarization/#notarize-without-a-stored-keychain-profile","text":"If you do not wish to store your information in a Keychain Profile, you can feed the information from Option 2 directly to PyDeployment for notarization. pydeploy myapp.spec -C 'Developer ID Application: Name Here (TEAMIDHERE)' -A <apple-id> -T <team-id> -P <password>","title":"Notarize Without a Stored Keychain Profile"},{"location":"user-guide/advanced/passing-args-to-pyi/","text":"Passing Arguments to PyInstaller Have PyDeployment pass arguments to PyInstaller. You can have PyDeployment ignore command line arguments and instead pass them to PyInstaller by using the separator -- . Any arguments after the -- separator will be ignored by PyDeployment and passed on to PyInstaller. This is useful when passing Python scripts to PyDeployment or when specifying parameters for a PyInstaller spec file. In the latter case, you will need to double the -- separator as PyInstaller itself uses it to pass parameters to a spec file.","title":"Passing Arguments to PyInstaller"},{"location":"user-guide/advanced/passing-args-to-pyi/#passing-arguments-to-pyinstaller","text":"Have PyDeployment pass arguments to PyInstaller. You can have PyDeployment ignore command line arguments and instead pass them to PyInstaller by using the separator -- . Any arguments after the -- separator will be ignored by PyDeployment and passed on to PyInstaller. This is useful when passing Python scripts to PyDeployment or when specifying parameters for a PyInstaller spec file. In the latter case, you will need to double the -- separator as PyInstaller itself uses it to pass parameters to a spec file.","title":"Passing Arguments to PyInstaller"},{"location":"user-guide/setting-options/","text":"Setting Build Options Set options for your project. There are two ways to set values for your project using PyDeployment: using an environment file, and using command line arguments. Both methods can be used simultaneously, with command line arguments overriding the options in the environment file. Click on the options below to learn about each of these methods. See available build options in Build Options . Using an Environment File Using the Command Line Using Both","title":"Setting Build Options"},{"location":"user-guide/setting-options/#setting-build-options","text":"Set options for your project. There are two ways to set values for your project using PyDeployment: using an environment file, and using command line arguments. Both methods can be used simultaneously, with command line arguments overriding the options in the environment file. Click on the options below to learn about each of these methods. See available build options in Build Options . Using an Environment File Using the Command Line Using Both","title":"Setting Build Options"},{"location":"user-guide/setting-options/command-line/","text":"Using the Command Line Set build options on the command line. You can use the command line to set build options. Format Setting a value on the command line takes the form Option Value where Option is the build option and Value is its value. Take care to enclose values containing white space with quotes. Example The following commands will all set my_app.py to have the filename 'myapp' , the app name 'My App' , and the version '0.1.0' . pydeploy -f myapp -a 'My App' --appv 0.1.0 my_app.py pydeploy my_app.py -f myapp -a 'My App' --appv 0.1.0 pydeploy -f myapp my_app.py -a 'My App' --appv 0.1.0 As you can see, the ordering of the arguments doesn't matter with a notable exception: when passing arguments to PyInstaller .","title":"Using the Command Line"},{"location":"user-guide/setting-options/command-line/#using-the-command-line","text":"Set build options on the command line. You can use the command line to set build options.","title":"Using the Command Line"},{"location":"user-guide/setting-options/command-line/#format","text":"Setting a value on the command line takes the form Option Value where Option is the build option and Value is its value. Take care to enclose values containing white space with quotes.","title":"Format"},{"location":"user-guide/setting-options/command-line/#example","text":"The following commands will all set my_app.py to have the filename 'myapp' , the app name 'My App' , and the version '0.1.0' . pydeploy -f myapp -a 'My App' --appv 0.1.0 my_app.py pydeploy my_app.py -f myapp -a 'My App' --appv 0.1.0 pydeploy -f myapp my_app.py -a 'My App' --appv 0.1.0 As you can see, the ordering of the arguments doesn't matter with a notable exception: when passing arguments to PyInstaller .","title":"Example"},{"location":"user-guide/setting-options/env-file/","text":"Using an Environment File Place build options in a file. You can place your build options in a file to avoid needing to list them out constantly. Setting the Environment File By default, PyDeployment pulls values from the environment file named .env in the current working directory. You can specify a different environment file with the environment variable ENV_FILE set to the path to your desired environment file. For example, on Windows, you can use the following command to pull values from an environment file named env_values.txt located in the current working directory. cmd /C \"set ENV_FILE=env_values.txt pydeploy myapp.py\" The equivalent command on macOS and Linux would be the following. env ENV_FILE=env_values.txt pydeploy myapp.py Format The environment file is a text file where each line takes the form Name=Value where Name is the name of the build option and Value is its value. Take care to enclose values containing white space with quotes. Platform-Specific Options You can set platform-specific options by prefixing variables in the environment file with their platform. The prefixes are WINDOWS_ , MACOS_ , and LINUX_ for Windows, macOS, and Linux, respectively. A common use case for platform-specific options is with the ICON option. WINDOWS_ICON=myapp.ico MACOS_ICON=myapp.icns LINUX_ICON=myapp.png Using this technique, you can easily keep all of your build options in a single file.","title":"Using an Environment File"},{"location":"user-guide/setting-options/env-file/#using-an-environment-file","text":"Place build options in a file. You can place your build options in a file to avoid needing to list them out constantly.","title":"Using an Environment File"},{"location":"user-guide/setting-options/env-file/#setting-the-environment-file","text":"By default, PyDeployment pulls values from the environment file named .env in the current working directory. You can specify a different environment file with the environment variable ENV_FILE set to the path to your desired environment file. For example, on Windows, you can use the following command to pull values from an environment file named env_values.txt located in the current working directory. cmd /C \"set ENV_FILE=env_values.txt pydeploy myapp.py\" The equivalent command on macOS and Linux would be the following. env ENV_FILE=env_values.txt pydeploy myapp.py","title":"Setting the Environment File"},{"location":"user-guide/setting-options/env-file/#format","text":"The environment file is a text file where each line takes the form Name=Value where Name is the name of the build option and Value is its value. Take care to enclose values containing white space with quotes.","title":"Format"},{"location":"user-guide/setting-options/env-file/#platform-specific-options","text":"You can set platform-specific options by prefixing variables in the environment file with their platform. The prefixes are WINDOWS_ , MACOS_ , and LINUX_ for Windows, macOS, and Linux, respectively. A common use case for platform-specific options is with the ICON option. WINDOWS_ICON=myapp.ico MACOS_ICON=myapp.icns LINUX_ICON=myapp.png Using this technique, you can easily keep all of your build options in a single file.","title":"Platform-Specific Options"},{"location":"user-guide/setting-options/using-both/","text":"Using Both Use both an environment file and the command line. Command line arguments override options set in the environment file. For example, the following two cases will yield the same build options. Case 1 Contents of .env FILENAME=myapp APPNAME='My App' VERSION=0.1.0 Command pydeploy myapp.py Case 2 Contents of .env FILENAME=testing VERSION=0.1.0 Command pydeploy -f myapp -a 'My App' myapp.py","title":"Using Both"},{"location":"user-guide/setting-options/using-both/#using-both","text":"Use both an environment file and the command line. Command line arguments override options set in the environment file. For example, the following two cases will yield the same build options. Case 1 Contents of .env FILENAME=myapp APPNAME='My App' VERSION=0.1.0 Command pydeploy myapp.py Case 2 Contents of .env FILENAME=testing VERSION=0.1.0 Command pydeploy -f myapp -a 'My App' myapp.py","title":"Using Both"}]}